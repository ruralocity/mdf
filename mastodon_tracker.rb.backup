#!/usr/bin/env ruby

require 'httparty'
require 'json'
require 'sqlite3'
require 'thor'
require 'time'
require 'set'
require 'stringio'

# TUI gems
require 'tty-box'
require 'tty-cursor'
require 'tty-screen'
require 'tty-table'
require 'tty-prompt'
require 'tty-spinner'
require 'pastel'

class MastodonTUI
  def initialize(tracker)
    @tracker = tracker
    @cursor = TTY::Cursor
    @pastel = Pastel.new
    @prompt = TTY::Prompt.new
    @running = true
  end

  def start
    setup_screen
    show_main_dashboard
  ensure
    cleanup_screen
  end

  private

  def setup_screen
    print @cursor.clear_screen
    print @cursor.hide
  end

  def cleanup_screen
    print @cursor.show
    print @cursor.move_to(0, TTY::Screen.height)
  end

  def show_main_dashboard
    while @running
      draw_main_dashboard
      handle_main_input
    end
  end

  def draw_main_dashboard
    print @cursor.move_to(0, 0)
    
    config = @tracker.load_config
    stats = get_current_stats
    recent_changes = get_recent_changes(5)
    
    # Header
    header = TTY::Box.frame(
      title: { top_left: " üêò Mastodon Follower Tracker " },
      width: TTY::Screen.width,
      height: 3,
      border: :thick
    ) do
      instance = config ? config[:instance].gsub('https://', '') : 'Not configured'
      "Instance: #{instance}#{' ' * 20}Last Check: #{get_last_check_time}"
    end
    
    # Stats section
    stats_content = if stats
      followers = stats[:followers] || 0
      following = stats[:following] || 0
      non_mutual = stats[:non_mutual] || 0
      
      "üìä Current Stats\n" +
      "   Followers: #{@pastel.green(followers)}    Following: #{@pastel.blue(following)}    Non-mutual: #{@pastel.yellow(non_mutual)}\n" +
      "   Today: #{format_daily_changes}"
    else
      "üìä No data available - run a check first"
    end
    
    stats_box = TTY::Box.frame(
      width: TTY::Screen.width,
      height: 6,
      border: :light
    ) { stats_content }
    
    # Recent changes section
    changes_content = if recent_changes.any?
      "üîÑ Recent Changes\n" + recent_changes.map do |change|
        time = Time.parse(change['timestamp']).strftime('%m-%d %H:%M')
        emoji = change['action'] == 'follow' ? 'üéâ' : 'üíî'
        action = change['action'] == 'follow' ? 'followed' : 'unfollowed'
        "   #{time}  #{emoji} #{change['display_name']} (@#{change['acct']}) #{action} you"
      end.join("\n")
    else
      "üîÑ Recent Changes\n   No recent changes - run a check to see activity"
    end
    
    changes_box = TTY::Box.frame(
      width: TTY::Screen.width,
      height: 8,
      border: :light
    ) { changes_content }
    
    # Menu
    menu_box = TTY::Box.frame(
      width: TTY::Screen.width,
      height: 3,
      border: :light
    ) { "[C]heck Now  [H]istory  [N]on-mutual  [F]ollowback  [S]ettings  [Q]uit" }
    
    print header + stats_box + changes_box + menu_box
  end

  def handle_main_input
    key = nil
    begin
      # Use a simpler approach for key input
      system("stty raw -echo")
      key = STDIN.getc
    ensure
      system("stty -raw echo")
    end
    
    case key&.downcase
    when 'c'
      run_check
    when 'h'
      show_history_view
    when 'n'
      show_non_mutual_view
    when 'f'
      show_followback_view
    when 's'
      show_settings
    when 'q'
      @running = false
    end
  end

  def run_check
    print @cursor.clear_screen
    print @cursor.move_to(0, 0)
    
    spinner = TTY::Spinner.new("[:spinner] Checking for follower changes...", format: :dots)
    spinner.auto_spin
    
    begin
      # Capture the output from the check command
      old_stdout = $stdout
      $stdout = StringIO.new
      
      @tracker.check
      
      output = $stdout.string
      $stdout = old_stdout
      
      spinner.success("Check complete!")
      
      # Show results
      puts "\n" + TTY::Box.frame(
        title: { top_left: " Check Results " },
        width: [60, TTY::Screen.width - 4].min,
        padding: 1
      ) { output }
      
      puts "\nPress any key to continue..."
      
      begin
        system("stty raw -echo")
        STDIN.getc
      ensure
        system("stty -raw echo")
      end
      
    rescue => e
      spinner.error("Check failed!")
      puts "\nError: #{e.message}"
      puts "Press any key to continue..."
      
      begin
        system("stty raw -echo")
        STDIN.getc
      ensure
        system("stty -raw echo")
      end
    ensure
      $stdout = old_stdout if old_stdout
    end
  end

  def show_history_view
    print @cursor.clear_screen
    print @cursor.move_to(0, 0)
    
    db = SQLite3::Database.new(@tracker.db_path)
    db.results_as_hash = true
    
    changes = db.execute("SELECT * FROM follower_changes ORDER BY timestamp DESC LIMIT 20")
    
    if changes.empty?
      content = "No history found. Run a check first!"
    else
      table = TTY::Table.new(
        header: ['Time', 'Action', 'User', 'Handle'],
        rows: changes.map do |change|
          time = Time.parse(change['timestamp']).strftime('%m-%d %H:%M')
          emoji = change['action'] == 'follow' ? 'üéâ' : 'üíî'
          action = change['action'] == 'follow' ? 'Follow' : 'Unfollow'
          [time, "#{emoji} #{action}", change['display_name'], "@#{change['acct']}"]
        end
      )
      content = table.render(:unicode, padding: [0, 1])
    end
    
    box = TTY::Box.frame(
      title: { top_left: " Follower History " },
      width: TTY::Screen.width,
      height: TTY::Screen.height - 3,
      padding: 1
    ) { content }
    
    puts box
    puts "[B]ack to main menu"
    
    key = nil
    loop do
      begin
        system("stty raw -echo")
        key = STDIN.getc
      ensure
        system("stty -raw echo")
      end
      
      case key&.downcase
      when 'b'
        break
      end
    end
    
    db.close
  end

  def show_non_mutual_view
    print @cursor.clear_screen
    print @cursor.move_to(0, 0)
    
    spinner = TTY::Spinner.new("[:spinner] Fetching non-mutual follows...", format: :dots)
    spinner.auto_spin
    
    begin
      config = @tracker.load_config
      return puts "Please run setup first!" unless config
      
      followers = @tracker.fetch_followers(config[:instance], config[:token])
      following = @tracker.fetch_following(config[:instance], config[:token])
      
      return puts "Failed to fetch data" unless followers && following
      
      follower_ids = followers.map { |f| f[:id] }.to_set
      non_mutual = following.reject { |f| follower_ids.include?(f[:id]) }
      
      spinner.success("Found #{non_mutual.length} non-mutual follows")
      
      if non_mutual.empty?
        puts "\nüéâ All accounts you follow also follow you back!"
        puts "Press any key to continue..."
        
        begin
          system("stty raw -echo")
          STDIN.getc
        ensure
          system("stty -raw echo")
        end
        return
      end
      
      # Interactive navigation
      current_index = 0
      selected = Set.new
      
      loop do
        print @cursor.clear_screen
        print @cursor.move_to(0, 0)
        
        # Header
        puts TTY::Box.frame(
          title: { top_left: " Non-Mutual Follows " },
          width: TTY::Screen.width,
          height: 3
        ) { "#{non_mutual.length} accounts ‚Ä¢ #{selected.length} selected ‚Ä¢ Use ‚Üë‚Üì to navigate" }
        
        # Account list with navigation
        display_start = [0, current_index - 5].max
        display_end = [non_mutual.length, display_start + 10].min
        
        (display_start...display_end).each do |idx|
          account = non_mutual[idx]
          checkbox = selected.include?(idx) ? '‚úì' : ' '
          followers_text = format_number(account[:followers_count])
          
          # Highlight current selection
          if idx == current_index
            line = @pastel.inverse(" > [#{checkbox}] #{account[:display_name]} (@#{account[:acct]}) - #{followers_text} followers ")
          else
            color = selected.include?(idx) ? :green : :white
            line = @pastel.decorate("   [#{checkbox}] #{account[:display_name]} (@#{account[:acct]}) - #{followers_text} followers", color)
          end
          
          puts line
        end
        
        puts "\n[‚Üë‚Üì] Navigate ‚Ä¢ [Space] Toggle ‚Ä¢ [I]nfo ‚Ä¢ [U]nfollow Selected ‚Ä¢ [A]ll ‚Ä¢ [N]one ‚Ä¢ [Q]uit"
        
        begin
          system("stty raw -echo")
          key = STDIN.getc
          
          # Handle arrow keys (they send escape sequences)
          if key == "\e"
            key += STDIN.read_nonblock(2) rescue ""
          end
        ensure
          system("stty -raw echo")
        end
        
        case key
        when "\e[A", 'k' # Up arrow or k
          current_index = [0, current_index - 1].max
        when "\e[B", 'j' # Down arrow or j
          current_index = [non_mutual.length - 1, current_index + 1].min
        when ' ' # Space to toggle
          if selected.include?(current_index)
            selected.delete(current_index)
          else
            selected.add(current_index)
          end
        when 'i', 'I'
          show_account_detail(non_mutual[current_index], config)
        when 'u', 'U'
          if selected.any?
            selected_accounts = selected.map { |i| non_mutual[i] }
            if confirm_bulk_unfollow(selected_accounts, config)
              break
            end
          end
        when 'a', 'A'
          selected = Set.new(0...non_mutual.length)
        when 'n', 'N'
          selected.clear
        when 'q', 'Q'
          break
        end
      end
      
    rescue => e
      spinner.error("Failed to fetch data")
      puts "Error: #{e.message}"
      puts "Press any key to continue..."
      
      begin
        system("stty raw -echo")
        STDIN.getc
      ensure
        system("stty -raw echo")
      end
    end
  end

  def show_followback_view
    print @cursor.clear_screen
    print @cursor.move_to(0, 0)
    
    spinner = TTY::Spinner.new("[:spinner] Finding accounts to follow back...", format: :dots)
    spinner.auto_spin
    
    begin
      config = @tracker.load_config
      return puts "Please run setup first!" unless config
      
      followers = @tracker.fetch_followers(config[:instance], config[:token])
      following = @tracker.fetch_following(config[:instance], config[:token])
      
      return puts "Failed to fetch data" unless followers && following
      
      following_ids = following.map { |f| f[:id] }.to_set
      followback_candidates = followers.reject { |f| following_ids.include?(f[:id]) }
      
      spinner.success("Found #{followback_candidates.length} accounts you could follow back")
      
      if followback_candidates.empty?
        puts "\nüéâ You already follow back everyone who follows you!"
        puts "Press any key to continue..."
        
        begin
          system("stty raw -echo")
          STDIN.getc
        ensure
          system("stty -raw echo")
        end
        return
      end
      
      # Interactive navigation
      current_index = 0
      selected = Set.new
      
      loop do
        print @cursor.clear_screen
        print @cursor.move_to(0, 0)
        
        # Header
        puts TTY::Box.frame(
          title: { top_left: " Follow Back Candidates " },
          width: TTY::Screen.width,
          height: 3
        ) { "#{followback_candidates.length} accounts ‚Ä¢ #{selected.length} selected ‚Ä¢ Use ‚Üë‚Üì to navigate" }
        
        # Account list with navigation
        display_start = [0, current_index - 5].max
        display_end = [followback_candidates.length, display_start + 10].min
        
        (display_start...display_end).each do |idx|
          account = followback_candidates[idx]
          checkbox = selected.include?(idx) ? '‚úì' : ' '
          followers_text = format_number(account[:followers_count])
          
          # Highlight current selection
          if idx == current_index
            line = @pastel.inverse(" > [#{checkbox}] #{account[:display_name]} (@#{account[:acct]}) - #{followers_text} followers ")
          else
            color = selected.include?(idx) ? :green : :white
            line = @pastel.decorate("   [#{checkbox}] #{account[:display_name]} (@#{account[:acct]}) - #{followers_text} followers", color)
          end
          
          puts line
        end
        
        puts "\n[‚Üë‚Üì] Navigate ‚Ä¢ [Space] Toggle ‚Ä¢ [I]nfo ‚Ä¢ [F]ollow Selected ‚Ä¢ [A]ll ‚Ä¢ [N]one ‚Ä¢ [Q]uit"
        
        begin
          system("stty raw -echo")
          key = STDIN.getc
          
          # Handle arrow keys (they send escape sequences)
          if key == "\e"
            key += STDIN.read_nonblock(2) rescue ""
          end
        ensure
          system("stty -raw echo")
        end
        
        case key
        when "\e[A", 'k' # Up arrow or k
          current_index = [0, current_index - 1].max
        when "\e[B", 'j' # Down arrow or j
          current_index = [followback_candidates.length - 1, current_index + 1].min
        when ' ' # Space to toggle
          if selected.include?(current_index)
            selected.delete(current_index)
          else
            selected.add(current_index)
          end
        when 'i', 'I'
          show_account_detail(followback_candidates[current_index], config)
        when 'f', 'F'
          if selected.any?
            selected_accounts = selected.map { |i| followback_candidates[i] }
            if confirm_bulk_follow(selected_accounts, config)
              break
            end
          end
        when 'a', 'A'
          selected = Set.new(0...followback_candidates.length)
        when 'n', 'N'
          selected.clear
        when 'q', 'Q'
          break
        end
      end
      
    rescue => e
      spinner.error("Failed to fetch data")
      puts "Error: #{e.message}"
      puts "Press any key to continue..."
      
      begin
        system("stty raw -echo")
        STDIN.getc
      ensure
        system("stty -raw echo")
      end
    end
  end

  def show_account_detail(account, config)
    print @cursor.clear_screen
    print @cursor.move_to(0, 0)
    
    spinner = TTY::Spinner.new("[:spinner] Fetching account details...", format: :dots)
    spinner.auto_spin
    
    begin
      # Fetch detailed account info
      account_details = @tracker.fetch_account_details(config[:instance], config[:token], account[:id])
      recent_posts = @tracker.fetch_account_posts(config[:instance], config[:token], account[:id], 3)
      
      spinner.success("Account details loaded")
      
      print @cursor.clear_screen
      print @cursor.move_to(0, 0)
      
      if account_details
        # Account header
        header_content = "#{account_details[:display_name]} (@#{account_details[:acct]})\n" +
                        "#{account_details[:url]}\n" +
                        "Joined: #{format_date(account_details[:created_at])}"
        
        header_box = TTY::Box.frame(
          title: { top_left: " Account Info " },
          width: TTY::Screen.width,
          height: 5,
          padding: 1
        ) { header_content }
        
        # Stats
        stats_content = "Followers: #{format_number(account_details[:followers_count])} | " +
                       "Following: #{format_number(account_details[:following_count])} | " +
                       "Posts: #{format_number(account_details[:statuses_count])}"
        
        stats_box = TTY::Box.frame(
          width: TTY::Screen.width,
          height: 3,
          border: :light
        ) { stats_content }
        
        # Bio
        bio_content = account_details[:note] ? strip_html(account_details[:note]) : "No bio available"
        bio_box = TTY::Box.frame(
          title: { top_left: " Bio " },
          width: TTY::Screen.width,
          height: 6,
          padding: 1
        ) { bio_content }
        
        # Recent posts
        posts_content = if recent_posts && recent_posts.any?
          "Recent Posts:\n\n" + recent_posts.map.with_index do |post, idx|
            content = strip_html(post[:content])
            content = content[0..200] + "..." if content.length > 200
            time = format_date(post[:created_at])
            "#{idx + 1}. #{time}\n   #{content}\n"
          end.join("\n")
        else
          "No recent posts available"
        end
        
        posts_box = TTY::Box.frame(
          title: { top_left: " Recent Activity " },
          width: TTY::Screen.width,
          height: 12,
          padding: 1
        ) { posts_content }
        
        print header_box + stats_box + bio_box + posts_box
      else
        puts "Failed to load account details"
      end
      
      puts "[F]ollow ‚Ä¢ [U]nfollow ‚Ä¢ [O]pen in browser ‚Ä¢ [B]ack"
      
      loop do
        begin
          system("stty raw -echo")
          key = STDIN.getc
        ensure
          system("stty -raw echo")
        end
        
        case key&.downcase
        when 'f'
          if @tracker.follow_account(config[:instance], config[:token], account[:id])
            puts "\n‚úÖ Followed #{account[:display_name]}"
          else
            puts "\n‚ùå Failed to follow #{account[:display_name]}"
          end
          sleep(1)
          break
        when 'u'
          if @tracker.unfollow_account(config[:instance], config[:token], account[:id])
            puts "\n‚úÖ Unfollowed #{account[:display_name]}"
          else
            puts "\n‚ùå Failed to unfollow #{account[:display_name]}"
          end
          sleep(1)
          break
        when 'o'
          if account_details && account_details[:url]
            system("open '#{account_details[:url]}'") # macOS
            puts "\nüåê Opened in browser"
            sleep(1)
          end
        when 'b'
          break
        end
      end
      
    rescue => e
      spinner.error("Failed to load account details")
      puts "Error: #{e.message}"
      puts "Press any key to continue..."
      
      begin
        system("stty raw -echo")
        STDIN.getc
      ensure
        system("stty -raw echo")
      end
    end
  end

  def format_date(date_string)
    return "Unknown" unless date_string
    Time.parse(date_string).strftime('%b %Y')
  rescue
    "Unknown"
  end

  def format_number(num)
    return "0" unless num
    num.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse
  end

  def strip_html(html)
    return "" unless html
    html.gsub(/<[^>]*>/, '').gsub(/&[^;]+;/, ' ').strip
  end

  def confirm_bulk_follow(selected_accounts, config)
    print @cursor.clear_screen
    print @cursor.move_to(0, 0)
    
    puts "About to follow #{selected_accounts.length} accounts:"
    selected_accounts.each do |account|
      puts "  ‚Ä¢ #{account[:display_name]} (@#{account[:acct]})"
    end
    
    puts "\nAre you sure you want to follow these accounts? [y/N]"
    
    begin
      system("stty raw -echo")
      response = STDIN.getc
    ensure
      system("stty -raw echo")
    end
    
    if response&.downcase == 'y'
      spinner = TTY::Spinner.new("[:spinner] Following accounts...", format: :dots)
      spinner.auto_spin
      
      followed = 0
      selected_accounts.each do |account|
        if @tracker.follow_account(config[:instance], config[:token], account[:id])
          followed += 1
        end
        sleep(1) # Rate limiting
      end
      
      spinner.success("Followed #{followed}/#{selected_accounts.length} accounts")
      puts "Press any key to continue..."
      
      begin
        system("stty raw -echo")
        STDIN.getc
      ensure
        system("stty -raw echo")
      end
      
      true
    else
      false
    end
  end

  def confirm_bulk_unfollow(selected_accounts, config)
    print @cursor.clear_screen
    print @cursor.move_to(0, 0)
    
    puts "About to unfollow #{selected_accounts.length} accounts:"
    selected_accounts.each do |account|
      puts "  ‚Ä¢ #{account[:display_name]} (@#{account[:acct]})"
    end
    
    puts "\nAre you sure you want to unfollow these accounts? [y/N]"
    
    begin
      system("stty raw -echo")
      response = STDIN.getc
    ensure
      system("stty -raw echo")
    end
    
    if response&.downcase == 'y'
      spinner = TTY::Spinner.new("[:spinner] Unfollowing accounts...", format: :dots)
      spinner.auto_spin
      
      unfollowed = 0
      selected_accounts.each do |account|
        if @tracker.unfollow_account(config[:instance], config[:token], account[:id])
          unfollowed += 1
        end
        sleep(1) # Rate limiting
      end
      
      spinner.success("Unfollowed #{unfollowed}/#{selected_accounts.length} accounts")
      puts "Press any key to continue..."
      
      begin
        system("stty raw -echo")
        STDIN.getc
      ensure
        system("stty -raw echo")
      end
      
      true
    else
      false
    end
  end
    selected_accounts = selected_indices.map { |i| followback_candidates[i] }
    
    print @cursor.clear_screen
    print @cursor.move_to(0, 0)
    
    puts "About to follow #{selected_accounts.length} accounts:"
    selected_accounts.each do |account|
      puts "  ‚Ä¢ #{account[:display_name]} (@#{account[:acct]})"
    end
    
    puts "\nAre you sure you want to follow these accounts? [y/N]"
    
    begin
      system("stty raw -echo")
      response = STDIN.getc
    ensure
      system("stty -raw echo")
    end
    
    if response&.downcase == 'y'
      spinner = TTY::Spinner.new("[:spinner] Following accounts...", format: :dots)
      spinner.auto_spin
      
      followed = 0
      selected_accounts.each do |account|
        if @tracker.follow_account(config[:instance], config[:token], account[:id])
          followed += 1
        end
        sleep(1) # Rate limiting
      end
      
      spinner.success("Followed #{followed}/#{selected_accounts.length} accounts")
      puts "Press any key to continue..."
      
      begin
        system("stty raw -echo")
        STDIN.getc
      ensure
        system("stty -raw echo")
      end
    end
  end

  def show_settings
    print @cursor.clear_screen
    print @cursor.move_to(0, 0)
    
    config = @tracker.load_config
    
    content = if config
      "Current Configuration:\n\n" +
      "Instance: #{config[:instance]}\n" +
      "Token: #{config[:token][0..10]}...\n\n" +
      "[R]econfigure ‚Ä¢ [B]ack"
    else
      "No configuration found.\n\n[S]etup ‚Ä¢ [B]ack"
    end
    
    box = TTY::Box.frame(
      title: { top_left: " Settings " },
      width: 60,
      height: 10,
      padding: 1
    ) { content }
    
    puts box
    
    key = nil
    loop do
      begin
        system("stty raw -echo")
        key = STDIN.getc
      ensure
        system("stty -raw echo")
      end
      
      case key&.downcase
      when 'r', 's'
        @tracker.setup
        break
      when 'b'
        break
      end
    end
  end

  def get_current_stats
    config = @tracker.load_config
    return nil unless config
    
    begin
      db = SQLite3::Database.new(@tracker.db_path)
      followers_count = db.execute("SELECT COUNT(*) FROM current_followers")[0][0]
      
      # This would require fetching following count - simplified for now
      {
        followers: followers_count,
        following: nil,
        non_mutual: nil
      }
    rescue
      nil
    ensure
      db&.close
    end
  end

  def get_recent_changes(limit = 5)
    begin
      db = SQLite3::Database.new(@tracker.db_path)
      db.results_as_hash = true
      db.execute("SELECT * FROM follower_changes ORDER BY timestamp DESC LIMIT ?", [limit])
    rescue
      []
    ensure
      db&.close
    end
  end

  def get_last_check_time
    # This would track last check time - simplified for now
    "Never"
  end

  def format_daily_changes
    # This would calculate today's changes - simplified for now
    "+0 followers, -0 unfollowers"
  end
end

class MastodonTracker < Thor
  desc "tui", "Launch the TUI interface"
  def tui
    config = load_config
    unless config
      puts "Please run setup first!"
      return
    end
    
    tui = MastodonTUI.new(self)
    tui.start
  end

  desc "setup", "Setup your Mastodon instance and access token"
  def setup
    puts "Setting up Mastodon Follower Tracker..."
    
    print "Enter your Mastodon instance URL (e.g., mastodon.social): "
    STDOUT.flush
    instance = STDIN.gets&.chomp&.strip
    
    # Validate and format instance URL
    if instance.nil? || instance.empty?
      puts "Error: Instance URL cannot be empty"
      return
    end
    
    instance = "https://#{instance}" unless instance.start_with?('http')
    
    # Basic URL validation
    unless instance.match?(/^https?:\/\/[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/)
      puts "Error: Invalid instance URL format"
      return
    end
    
    print "Enter your access token: "
    STDOUT.flush
    token = STDIN.gets&.chomp&.strip
    
    if token.nil? || token.empty?
      puts "Error: Access token cannot be empty"
      return
    end
    
    save_config(instance, token)
    init_database
    
    puts "Setup complete! Run 'ruby mastodon_tracker.rb tui' to launch the TUI interface."
  end

  desc "check", "Check for new followers/unfollowers"
  def check
    config = load_config
    return puts "Please run setup first!" unless config
    
    current_followers = fetch_followers(config[:instance], config[:token])
    return puts "Failed to fetch followers" unless current_followers
    
    previous_followers = get_previous_followers
    
    if previous_followers.empty?
      puts "First run - storing #{current_followers.length} followers"
      store_followers(current_followers)
      return
    end
    
    new_followers = current_followers - previous_followers
    unfollowers = previous_followers - current_followers
    
    if new_followers.any?
      puts "\nüéâ New followers (#{new_followers.length}):"
      new_followers.each { |f| puts "  + #{f[:display_name]} (@#{f[:acct]})" }
      log_changes(new_followers, 'follow')
    end
    
    if unfollowers.any?
      puts "\nüíî Unfollowers (#{unfollowers.length}):"
      unfollowers.each { |f| puts "  - #{f[:display_name]} (@#{f[:acct]})" }
      log_changes(unfollowers, 'unfollow')
    end
    
    if new_followers.empty? && unfollowers.empty?
      puts "No changes in followers"
    end
    
    store_followers(current_followers)
    puts "\nTotal followers: #{current_followers.length}"
  end

  desc "history", "Show follower change history"
  def history
    db = SQLite3::Database.new(db_path)
    db.results_as_hash = true
    
    changes = db.execute("SELECT * FROM follower_changes ORDER BY timestamp DESC LIMIT 50")
    
    if changes.empty?
      puts "No history found. Run 'check' first!"
      return
    end
    
    puts "Recent follower changes:\n"
    changes.each do |change|
      time = Time.parse(change['timestamp']).strftime('%Y-%m-%d %H:%M')
      action = change['action'] == 'follow' ? 'üéâ' : 'üíî'
      puts "#{time} #{action} #{change['display_name']} (@#{change['acct']})"
    end
  end

  desc "non_mutual", "Show accounts you follow who don't follow you back (with optional unfollowing)"
  option :interactive, type: :boolean, default: false, aliases: '-i', desc: 'Interactively unfollow accounts'
  def non_mutual
    config = load_config
    return puts "Please run setup first!" unless config
    
    puts "Fetching your followers..."
    followers = fetch_followers(config[:instance], config[:token])
    return puts "Failed to fetch followers" unless followers
    
    puts "Fetching accounts you follow..."
    following = fetch_following(config[:instance], config[:token])
    return puts "Failed to fetch following list" unless following
    
    follower_ids = followers.map { |f| f[:id] }.to_set
    
    non_mutual = following.reject { |f| follower_ids.include?(f[:id]) }
    
    if non_mutual.empty?
      puts "üéâ All accounts you follow also follow you back!"
      return
    end
    
    puts "\nüíî Accounts you follow who don't follow back (#{non_mutual.length}):"
    
    if options[:interactive]
      unfollowed_count = 0
      
      non_mutual.each_with_index do |account, index|
        puts "\n[#{index + 1}/#{non_mutual.length}] #{account[:display_name]} (@#{account[:acct]})"
        puts "  Followers: #{account[:followers_count]} | Following: #{account[:following_count]}"
        
        print "Unfollow this account? [y/N/q(uit)]: "
        response = STDIN.gets.chomp.downcase
        
        case response
        when 'y', 'yes'
          if unfollow_account(config[:instance], config[:token], account[:id])
            puts "  ‚úÖ Unfollowed #{account[:display_name]}"
            unfollowed_count += 1
          else
            puts "  ‚ùå Failed to unfollow #{account[:display_name]}"
          end
        when 'q', 'quit'
          puts "Stopping..."
          break
        else
          puts "  ‚è≠Ô∏è  Skipped"
        end
        
        sleep(1) # Rate limiting
      end
      
      puts "\nüìä Summary:"
      puts "Accounts unfollowed: #{unfollowed_count}"
    else
      non_mutual.each do |account|
        puts "  #{account[:display_name]} (@#{account[:acct]}) - #{account[:followers_count]} followers"
      end
      
      puts "\nüí° Tip: Use --interactive or -i to interactively unfollow accounts"
    end
    
    puts "\nSummary:"
    puts "You follow: #{following.length}"
    puts "Follow you: #{followers.length}"
    puts "Non-mutual: #{non_mutual.length}"
  end

  desc "profile ACCOUNT_HANDLE", "Show detailed profile information for an account"
  def profile(account_handle)
    config = load_config
    return puts "Please run setup first!" unless config
    
    puts "Searching for account: #{account_handle}"
    
    # Search for the account
    search_url = "#{config[:instance]}/api/v2/search?q=#{account_handle}&type=accounts&limit=1"
    
    response = HTTParty.get(search_url, headers: {
      'Authorization' => "Bearer #{config[:token]}"
    })
    
    unless response.success?
      puts "Failed to search for account: #{response.code}"
      return
    end
    
    accounts = response.parsed_response['accounts']
    if accounts.empty?
      puts "Account not found: #{account_handle}"
      return
    end
    
    account = accounts.first
    account_id = account['id']
    
    # Get detailed info
    details = fetch_account_details(config[:instance], config[:token], account_id)
    posts = fetch_account_posts(config[:instance], config[:token], account_id, 5)
    
    if details
      puts "\n" + "="*60
      puts "#{details[:display_name]} (@#{details[:acct]})"
      puts "="*60
      puts "URL: #{details[:url]}"
      puts "Joined: #{Time.parse(details[:created_at]).strftime('%B %Y')}" if details[:created_at]
      puts "Bot: #{details[:bot] ? 'Yes' : 'No'}"
      puts "Locked: #{details[:locked] ? 'Yes' : 'No'}"
      puts
      puts "üìä Stats:"
      puts "  Followers: #{details[:followers_count].to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}"
      puts "  Following: #{details[:following_count].to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}"
      puts "  Posts: #{details[:statuses_count].to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse}"
      puts
      puts "üìù Bio:"
      bio = details[:note] ? details[:note].gsub(/<[^>]*>/, '').gsub(/&[^;]+;/, ' ').strip : "No bio"
      puts "  #{bio}"
      
      if posts.any?
        puts "\nüìÆ Recent Posts:"
        posts.each_with_index do |post, idx|
          content = post[:content].gsub(/<[^>]*>/, '').gsub(/&[^;]+;/, ' ').strip
          content = content[0..200] + "..." if content.length > 200
          time = Time.parse(post[:created_at]).strftime('%m/%d %H:%M')
          puts "\n  #{idx + 1}. #{time}"
          puts "     #{content}"
          puts "     ‚ù§Ô∏è #{post[:favourites_count]} üîÑ #{post[:reblogs_count]} üí¨ #{post[:replies_count]}"
        end
      end
    else
      puts "Failed to fetch account details"
    end
  end

  desc "followback", "Show accounts that follow you but you don't follow back (with optional following)"
  option :interactive, type: :boolean, default: false, aliases: '-i', desc: 'Interactively follow accounts'
  def followback
    config = load_config
    return puts "Please run setup first!" unless config
    
    puts "Fetching your followers..."
    followers = fetch_followers(config[:instance], config[:token])
    return puts "Failed to fetch followers" unless followers
    
    puts "Fetching accounts you follow..."
    following = fetch_following(config[:instance], config[:token])
    return puts "Failed to fetch following list" unless following
    
    following_ids = following.map { |f| f[:id] }.to_set
    
    followback_candidates = followers.reject { |f| following_ids.include?(f[:id]) }
    
    if followback_candidates.empty?
      puts "üéâ You already follow back everyone who follows you!"
      return
    end
    
    puts "\nüíô Accounts you could follow back (#{followback_candidates.length}):"
    
    if options[:interactive]
      followed_count = 0
      
      followback_candidates.each_with_index do |account, index|
        puts "\n[#{index + 1}/#{followback_candidates.length}] #{account[:display_name]} (@#{account[:acct]})"
        puts "  Followers: #{account[:followers_count]} | Following: #{account[:following_count]}"
        
        print "Follow this account? [y/N/q(uit)]: "
        response = STDIN.gets.chomp.downcase
        
        case response
        when 'y', 'yes'
          if follow_account(config[:instance], config[:token], account[:id])
            puts "  ‚úÖ Followed #{account[:display_name]}"
            followed_count += 1
          else
            puts "  ‚ùå Failed to follow #{account[:display_name]}"
          end
        when 'q', 'quit'
          puts "Stopping..."
          break
        else
          puts "  ‚è≠Ô∏è  Skipped"
        end
        
        sleep(1) # Rate limiting
      end
      
      puts "\nüìä Summary:"
      puts "Accounts followed: #{followed_count}"
    else
      followback_candidates.each do |account|
        puts "  #{account[:display_name]} (@#{account[:acct]}) - #{account[:followers_count]} followers"
      end
      
      puts "\nüí° Tip: Use --interactive or -i to interactively follow accounts"
    end
    
    puts "\nSummary:"
    puts "Follow you: #{followers.length}"
    puts "You follow: #{following.length}"
    puts "Could follow back: #{followback_candidates.length}"
  end

  desc "stats", "Show follower statistics"
  def stats
    db = SQLite3::Database.new(db_path)
    
    total = db.execute("SELECT COUNT(*) FROM current_followers")[0][0]
    
    follows = db.execute("SELECT COUNT(*) FROM follower_changes WHERE action = 'follow'")[0][0]
    unfollows = db.execute("SELECT COUNT(*) FROM follower_changes WHERE action = 'unfollow'")[0][0]
    
    puts "üìä Follower Statistics:"
    puts "Current followers: #{total}"
    puts "Total follows tracked: #{follows}"
    puts "Total unfollows tracked: #{unfollows}"
    puts "Net change: +#{follows - unfollows}"
  end

  # Public methods for TUI access
  no_commands do
    def load_config
      return nil unless File.exist?(config_path)
      
      config = JSON.parse(File.read(config_path), symbolize_names: true)
      
      # Validate config
      if config[:instance].nil? || config[:instance].strip.empty? || 
         config[:token].nil? || config[:token].strip.empty?
        puts "Error: Invalid configuration. Please run setup again."
        return nil
      end
      
      config
    rescue JSON::ParserError
      puts "Error: Corrupted configuration file. Please run setup again."
      nil
    end

    def db_path
      File.expand_path('~/.mastodon_tracker.db')
    end

    def fetch_followers(instance, token)
      url = "#{instance}/api/v1/accounts/verify_credentials"
      
      response = HTTParty.get(url, headers: {
        'Authorization' => "Bearer #{token}"
      })
      
      unless response.success?
        puts "Failed to verify credentials: #{response.code}"
        return nil
      end
      
      account_id = response['id']
      followers = []
      next_url = "#{instance}/api/v1/accounts/#{account_id}/followers?limit=80"
      
      while next_url
        response = HTTParty.get(next_url, headers: {
          'Authorization' => "Bearer #{token}"
        })
        
        unless response.success?
          puts "Failed to fetch followers: #{response.code}"
          return nil
        end
        
        batch = response.parsed_response.map do |follower|
          {
            id: follower['id'],
            acct: follower['acct'],
            display_name: follower['display_name'] || follower['username'],
            followers_count: follower['followers_count'],
            following_count: follower['following_count'],
            created_at: follower['created_at']
          }
        end
        
        followers.concat(batch)
        
        link_header = response.headers['link']
        next_url = parse_next_url(link_header)
        
        sleep(0.5) # Rate limiting
      end
      
      followers
    end

    def fetch_following(instance, token)
      url = "#{instance}/api/v1/accounts/verify_credentials"
      
      response = HTTParty.get(url, headers: {
        'Authorization' => "Bearer #{token}"
      })
      
      unless response.success?
        puts "Failed to verify credentials: #{response.code}"
        return nil
      end
      
      account_id = response['id']
      following = []
      next_url = "#{instance}/api/v1/accounts/#{account_id}/following?limit=80"
      
      while next_url
        response = HTTParty.get(next_url, headers: {
          'Authorization' => "Bearer #{token}"
        })
        
        unless response.success?
          puts "Failed to fetch following list: #{response.code}"
          return nil
        end
        
        batch = response.parsed_response.map do |account|
          {
            id: account['id'],
            acct: account['acct'],
            display_name: account['display_name'] || account['username'],
            followers_count: account['followers_count'],
            following_count: account['following_count'],
            created_at: account['created_at']
          }
        end
        
        following.concat(batch)
        
        link_header = response.headers['link']
        next_url = parse_next_url(link_header)
        
        sleep(0.5) # Rate limiting
      end
      
      following
    end

    def fetch_account_details(instance, token, account_id)
      url = "#{instance}/api/v1/accounts/#{account_id}"
      
      response = HTTParty.get(url, headers: {
        'Authorization' => "Bearer #{token}"
      })
      
      if response.success?
        account = response.parsed_response
        {
          id: account['id'],
          acct: account['acct'],
          display_name: account['display_name'] || account['username'],
          note: account['note'],
          url: account['url'],
          followers_count: account['followers_count'],
          following_count: account['following_count'],
          statuses_count: account['statuses_count'],
          created_at: account['created_at'],
          avatar: account['avatar'],
          header: account['header'],
          bot: account['bot'],
          locked: account['locked']
        }
      else
        nil
      end
    end

    def fetch_account_posts(instance, token, account_id, limit = 5)
      url = "#{instance}/api/v1/accounts/#{account_id}/statuses?limit=#{limit}&exclude_replies=true&exclude_reblogs=true"
      
      response = HTTParty.get(url, headers: {
        'Authorization' => "Bearer #{token}"
      })
      
      if response.success?
        response.parsed_response.map do |post|
          {
            id: post['id'],
            content: post['content'],
            created_at: post['created_at'],
            favourites_count: post['favourites_count'],
            reblogs_count: post['reblogs_count'],
            replies_count: post['replies_count']
          }
        end
      else
        []
      end
    end

    def follow_account(instance, token, account_id)
      url = "#{instance}/api/v1/accounts/#{account_id}/follow"
      
      response = HTTParty.post(url, headers: {
        'Authorization' => "Bearer #{token}",
        'Content-Type' => 'application/json'
      })
      
      response.success?
    end

    def unfollow_account(instance, token, account_id)
      url = "#{instance}/api/v1/accounts/#{account_id}/unfollow"
      
      response = HTTParty.post(url, headers: {
        'Authorization' => "Bearer #{token}",
        'Content-Type' => 'application/json'
      })
      
      response.success?
    end
  end

  private

  def config_path
    File.expand_path('~/.mastodon_tracker_config.json')
  end

  def save_config(instance, token)
    config = { instance: instance, token: token }
    File.write(config_path, JSON.pretty_generate(config))
  end

  def init_database
    db = SQLite3::Database.new(db_path)
    
    db.execute <<-SQL
      CREATE TABLE IF NOT EXISTS current_followers (
        id TEXT PRIMARY KEY,
        acct TEXT,
        display_name TEXT,
        followers_count INTEGER,
        following_count INTEGER,
        created_at TEXT
      )
    SQL
    
    db.execute <<-SQL
      CREATE TABLE IF NOT EXISTS follower_changes (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        follower_id TEXT,
        acct TEXT,
        display_name TEXT,
        action TEXT,
        timestamp TEXT
      )
    SQL
    
    db.close
  end

  def parse_next_url(link_header)
    return nil unless link_header
    
    links = link_header.split(',')
    next_link = links.find { |link| link.include?('rel="next"') }
    return nil unless next_link
    
    next_link.match(/<([^>]+)>/)[1]
  end

  def get_previous_followers
    db = SQLite3::Database.new(db_path)
    db.results_as_hash = true
    
    rows = db.execute("SELECT * FROM current_followers")
    
    rows.map do |row|
      {
        id: row['id'],
        acct: row['acct'],
        display_name: row['display_name'],
        followers_count: row['followers_count'],
        following_count: row['following_count'],
        created_at: row['created_at']
      }
    end
  ensure
    db&.close
  end

  def store_followers(followers)
    db = SQLite3::Database.new(db_path)
    
    db.execute("DELETE FROM current_followers")
    
    followers.each do |follower|
      db.execute(
        "INSERT INTO current_followers VALUES (?, ?, ?, ?, ?, ?)",
        [follower[:id], follower[:acct], follower[:display_name], 
         follower[:followers_count], follower[:following_count], follower[:created_at]]
      )
    end
  ensure
    db&.close
  end

  def log_changes(followers, action)
    db = SQLite3::Database.new(db_path)
    
    followers.each do |follower|
      db.execute(
        "INSERT INTO follower_changes (follower_id, acct, display_name, action, timestamp) VALUES (?, ?, ?, ?, ?)",
        [follower[:id], follower[:acct], follower[:display_name], action, Time.now.iso8601]
      )
    end
  ensure
    db&.close
  end
end

MastodonTracker.start(ARGV)